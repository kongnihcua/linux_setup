<html>
<head>
    <title>Linux Setup</title>
    <meta content="" charset="UTF-8">
    <style>
        h2 {margin-top: 100pt; margin-bottom: 5pt;}
        h3 {margin-top: 20pt; margin-bottom: 5pt;}
        p {margin-top: 10pt; margin-bottom: 10pt;}
        code {color:blue;}
        pre {color: green;}
        #navbar-container {
            overflow-y: auto;
            position: fixed;
            padding-top: 10vh;
            padding-bottom: 10vh;
            padding-left: 3vw;
            width: 24vw;
            height: 100%;
            box-sizing: border-box;
        }
        #navbar p {
            margin: 24px 0;
        }
        #content {
            margin-left: 30vw;
            margin-right: 30vw;
            display: inline-block;
        }
    </style>
</head>

<script>
const load = _ => {
    console.log('loading navbar...')
    let headers_2 = [...document.getElementsByTagName('h2')]
    let navbar = document.getElementById('navbar')
    headers_2.map( x => {
        // add id attribute
        x.setAttribute('id',x.innerHTML.replace(' ','_'))
        // create link
        let p = document.createElement('p')
        let a = document.createElement('a')
        a.setAttribute('href','#' + x.getAttribute('id'))
        a.innerHTML = x.innerHTML

        p.appendChild(a)
        // add link to navbar
        navbar.appendChild(p)
        // add line break
        // navbar.appendChild(document.createElement('br'))
    })
}
</script>

<body onload='load()'>

<div id='navbar-container'><div id='navbar'></div></div>

<div id='content'>

<h2>System Settings</h2>
<h3>Thunderbolt Authorization</h3>
<p>check the UUID of target device:</p>
<code>boltctl</code>
<p>authoritze device to allow usb peripheral connections:</p>
<code>boltctl authorize DEVICE_UUID</code>

<h2>User Management</h2>
<h3>Adding/ Deleting a User</h3>
<code>sudo adduser userName</code>
<br>
<code>sudo userdel userName</code>
<h3>Changing Password</h3>
<code>passwd</code>
<h3>Show groups a user belongs</h3>
<code>groups</code>
<h3>Adding a Sudoer</h3>
<p>edit /etc/sudoers using visudo:</p>
<code>sudo visudo</code>
<p>and place the following line:</p>
<code>youruser    ALL=(ALL) NOPASSWD:ALL</code>
<p>after</p>
<pre># Allow members of group sudo to execute any command
  %sudo   ALL=(ALL:ALL) ALL</pre>
<p>the <code>NOPASSWD</code> keyword will disable the password prompt when you call <code>sudo</code> .</p>

<h2>Setup Desktop Enviornment</h2>
<p>Personally i've been using KDE as desktop environment. It comprises a bundle of softwares of names usually containing the letter 'k'. Plamsa Desktop provides a windows-like experience and virtual desktop is helpful when you want to separate programs of different contexts</p>
<p>install the full suite:</p>
<code>sudo apt install kde-full</code>
<p>OR only install the core applications that i find most useful:</p>
<code>sudo apt install dolphin kate konsole plasma-desktop</code>
<h3>Keyboard Shortcuts</h3>
<p>keyboard shortcuts can be set at Global Keyboard Shortcuts</p>
<table>
    <tr><th>Shortcut</th><th>Action</th></tr>
    <tr><td><kbd>META</kbd> + <kbd>E</kbd></td><td>Dolphin</td></tr>
    <tr><td><kbd>CTRL</kbd> + <kbd>ALT</kbd> + <kbd>T</kbd></td><td>Konsole</td></tr>
</table>

<h2>Setup ~/workspace</h2>
<p>a flattest possible folder hierarchy benefits readability of scripts and consistent naming enhance portability. I organise all repositories, public or private into a single folder:</p>
<code>~/workspace/</code>

<h2>Access Windows Network Drive</h2>
<p>install requirement:</p>
<code>sudo apt install cifs-utils</code>
<p>mount network drive directory:</p>
<code>sudo mount -t cifs -o username=USERNAME,uid=$(id -u) //DRIVE_IP/team/ /mnt/FILESYSTEM</code>

<h3>Setup Git</h3>
<p>store your credentials for push/pull without authentication:</p>
<code>git config credential.helper store</code>

<h2>Setup PostgresSQL</h2>
Environment: Ubuntu Focal
<h3>install dependencies</h3>
<ul>
  <li><code>sudo apt install bison flex zlib1g-dev libreadline-dev</code></li>
</ul>
<h3>compile and installation on local folder</h3>
<ul>
  <li><code>cd ~/workspace</code></li>
  <li><code>git clone https://github.com/postgres/postgres</code></li>
  <li><code>cd postgres</code></li>
  <li><code>git checkout REL_13_1</code></li>
  <li><code>./configure --prefix=/home/andyau/workspace/postgres/build</code></li>
  <li><code>make</code></li>
  <li><code>make install</code></li>
</ul>

<h3>setup Environmetal Variable for better readability</h3>
<code>export PG=$HOME/workspace/postgres/build/bin && export LD_LIBRARY_PATH=$HOME/workspace/postgres/build/lib</code>

<h3>initialize a new Database Cluster in target folder</h3>
<p>note: this only initialize the directory file system for postgres to work.</p>
<code>$PG/initdb -D YOUR_PROJECT_DIRECTORY/data</code>

<h3>start Postgres Server instance</h3>
<code>$PG/postgres -D YOUR_PROJECT_DIRECTORY/data</code>

<p>now things should be running. create a database base: </p>
<li><code>$PG/createdb DB_NAME</code></li>


<h2>Remove a file from git repo history.</h2>
<code>git filter-branch --index-filter 'git rm -rf --cached --ignore-unmatch target_file_path' HEAD</code>


<h2>Access Client Shell of PostgresSQL</h2>
<code>$PG/psql DB_NAME</code>

<h2>Setup PostGIS</h2>
<h3>install dependencies</h3>
<li><code>sudo apt install autoconf libtool libxml2-dev libgeos-dev libproj-dev libgdal-dev</code></li>
<p>where GEOS is a library for performing operations on two-dimensional vector geometries.</p>

<h3>compile and installation on local folder</h3>
<ul>
  <li><code>cd ~/workspace</code></li>
  <li><code>git clone https://git.osgeo.org/gitea/postgis/postgis.git</code></li>
  <li><code>cd postgis</code></li>
  <li><code>git checkout 3.1.0alpha2</code></li>
  <li><code>./autogen.sh</code></li>
  <li><code>./configure --with-pgconfig=$PG/pg_config</code></li>
  <li><code>make</code></li>
  <li><code>make install</code></li>
</ul>
<details>
    <summary>the library files and executables will be installed to Postgres library:</summary>
    <pre>
        For your info, using the values determined from 
        /home/andyau/workspace/postgres/build/bin/pg_config we will be installing:   
          * postgis shared library in /home/andyau/workspace/postgres/build/lib 
          * postgis SQL files in /home/andyau/workspace/postgres/build/share/contrib/postgis-3.1 
          * postgis executables in /home/andyau/workspace/postgres/build/bin
    </pre>
</details>

<h2>Access Point Mode for Raspberry Pi 4B</h2>
<p><code>nmtui</code> (Network Manager) is used in place of the default <code>dhcpcd</code></p>
<p>remove dhcpcd5</p>
<code>sudo apt remove --purge dhcpcd5</code>
<p>install dependencies:</p>
<code>sudo apt install network-manager</code>
<p>then create the connection profile via:</p>
<code>sudo nmtui</code>
<p>set the mode to Access Point and IPv4 to shared. connect to the access point profile via:</p>
<code>sudo nmcli con up 'access_point_profile'</code>
<p>neither nmtui nor the panel network icon seem to work</p>


<p>If you want to share the internet of a raspberry pi to multiple users, you can configure one of the Network Interfaces of a raspberry pi into access point mode. Here i will present a scenario:</p>
<h3>share internet for devices of a booth</h3>
<p>prepare a simple home router</p>
<p>via a Physical Ethernet cable, connect the raspberry to the WLAN port of the router which is also the default gateway of the network. (The default gateway is where TCP packets will be sent to if the Packet's IP Address does not match any recognised subnets.)</p>
<p>access to Raspberry and set up the Ethernet Network Interface as a Access Point:</p>
<code>sudo nmtui</code>
<p>add a new connection and set its profile name as <code>Ethernet Access Point</code>. By default any clients will be assigned the IP in subnet 10.47.0.X/24</p>
<p>restrict the profile only to the ethernet device, such as <code>eth0</code></p>
<p>under <code>IPv4 CONFIGURATION</code>, select <code>Shared</code></p>
<p>check the box <code>Automatically connect</code></p>
<p>finish the setup</p>


<h2>Minimal Network Setup without Monitor on a Raspberry Pi 4B</h2>
<p>for the first time setting up a new raspberry pi with minimal effort and without monitor</p>
<h3>Flash OS onto a microSD card</h3>
<p>Obtain Image:</p>
<code>wget https://downloads.raspberrypi.com/raspios_lite_armhf/images/raspios_lite_armhf-2024-03-15/2024-03-15-raspios-bookworm-armhf-lite.img.xz</code>
<p>Decompress Image</p>
<p>Plug in SD card, identify the partition in <code>df</code>, in our case <code>/dev/mmcblk0</code>. If it is also auto mounted, as shown in <code>sudo fdisk -l</code>, run e.g.:</p>
<code>sudo umount /media/kongnihcua/1f84f91b-62f9-45f7-ac48-38ce064f32c1</code>
<p>Format the card:</p>
<code>sudo mkfs.ext4 /dev/mmcblk0</code>
<p>Flash image:</p>
<code>sudo dd if=./rraspios_lite_armhf-2024-03-15/2024-03-15-raspios-bookworm-armhf-lite.img of=/dev/mmcblk0 bs=2M conv=fsync</code>
<p>Create a salted password hash for the new user:</p>
<code>openssl passwd -6</code>
<p>create a file named <code>userconf.txt</code> in the boot directory. the content should be a single line in the form of user:pass_hash. for example:</p>
<code>pi:$6$Xr8FTxVfvDBL73V4$3vZ9/JeAWxv20/msU6qiXz/LWHBfqDX0a8vpwEk/MLagq60xQKf1Rp0PP8lxGFQ8el7q58gcpujiaf11oN40N1</code>
<p>make sure there is no unnecessary space. if the wrong hash is used and the raspberry is started, it will create an inaccessible account. to fix simply edit the file <code>/etc/passwd</code></p>
<p>Open the <code>boot</code> folder, edit the following lines in <code>config.txt</code>:</p>
<pre>
framebuffer_width=1280 # recommend 1024 for 7" touch screen
framebuffer_width=720 # recommend 614 for 7" touch screen
</pre>
<p>create an empty file named <code>ssh</code> in the boot directory</p>
<p>create a file named <code>wpa_supplicant.conf</code> in the boot directory:</p>
<pre>
country=DE
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="NETWORK-NAME"
    psk="NETWORK-PASSWORD"
}
</pre>
<p>edit the hostname by editing the file <code>rootfs/etc/hostname</code> and <code>rootfs/etc/hosts</code></p>
<p>eject the SD card</p>
<p>insert the SD card to Raspberry Pi and boot it up.</p>
<p>identify the IP address of the Raspberry, then ssh to the Raspberry with username pi and password raspberry</p>
<p>setup the following items via <code>sudo raspi-config</code></p>
<ul>
    <li>Wireless Lan (in case where /etc/wpa_supplicant/wpa_supplicant.conf is still empty)</li>
    <li>Password (optional)</li>
    <li>Hostname (in case where /etc/hostname is not updated)</li>
    <li>SSH</li>
    <li>VNC (optional)</li>
    <li>Display Resolution (if headless mode and VNC is needed, set to same as framebuffer)</li>
</ul>
<p>reboot</p>


<h2>Change Pin Functions of Raspberry</h2>
<p>get the pinout diagram:</p>
<code>pinout</code>
<p>check the functions of each GPIO:</p>
<code>raspi-gpio funcs</code>
<p>modify the pin functions by editing device-tree</p>
<code>dtoverlay uart4</code>
<p>check the current pin settings:</p>
<code>raspi-gpio get 0-15</code>

<h2>Rotate Display of Touch Screen for Raspberry</h2>
<p>Add the following line to <code>/boot/config.txt</code> around the framebuffer section</p>
<code>lcd_rotate=2</code>
<p>to calibrate the screen, install the calibrator:</p>
<code>sudo apt install xinput-calibrator</code>
<p>run the calibrator</p>
<code>xinput_calibrator</code>


<h2>Create Raspberry Pi SD Card Image File</h2>
<code>sudo dd if=/dev/mmcblk0 | gzip > raspi_backup.img.gz</code>
<p>to restore image, plugin a new sd card</p>
<p>Format the card:</p>
<code>sudo mkfs.ext4 /dev/mmcblk0</code>
<p>flash the image:</p>
<code>cat raspi_backup.img.gz | gunzip | sudo dd of=/dev/mmcblk0</code>


<!-- <h2>Sync Raspbian to GPS Time in internet denied area</h2>
<p>raspberry has a minimal ntp client provided by the <code>systemd-timesyncd</code> service daemon. By default it is in auto mode where changing of time is restricted.</p>
<p>if you boot the raspberry without internet access, you can make use of GPS time to set the hardware clock.</p> -->


<h2>Setup OpenWRT on Raspberry Pi 4B</h2>
<h3>Flash OS onto a microSD card</h3>
<p>Obtain Image:</p>
<code>wget https://downloads.openwrt.org/snapshots/targets/bcm27xx/bcm2711/openwrt-bcm27xx-bcm2711-rpi-4-ext4-factory.img.gz</code>
<p>Take the optional step to inspect the checksum:</p>
<code>sha256sum openwrt-bcm27xx-bcm2711-rpi-4-ext4-factory.img.gz</code>
<p>Decompress Image:</p>
<code>gzip --decompress openwrt-bcm27xx-bcm2711-rpi-4-ext4-factory.img.gz</code>
<p>Plug in SD card, identify the partition in <code>df</code>, in our case <code>/dev/mmcblk0</code>. If it is also auto mounted, as shown in <code>sudo fdisk -l</code>, run e.g.:</p>
<code>sudo umount /media/auchingnok/1f84f91b-62f9-45f7-ac48-38ce064f32c1</code>
<p>Format the card:</p>
<code>sudo mkfs.ext4 /dev/mmcblk0</code>
<p>Flash image:</p>
<code>sudo dd if=./openwrt-bcm27xx-bcm2711-rpi-4-ext4-factory.img of=/dev/mmcblk0 bs=2M conv=fsync</code>
<p>Plugin the SD to Raspberry 4 and boot. Wait for a while for the boot phase, press <kbd>Enter</kbd> to access the command line interface.</p>

<h3>Change the password</h3>
<p>for better security, remember to change the password of root first</p>
<code>passwd</code>

<h3>Setup Network Interface</h3>
<p>Change the default static ip address of ethernet card</p>
<code>vim /etc/config/network</code>
<p>under section <code>config interface 'lan'</code>, the concerning line be <code>option ipaddr '192.168.0.10'
</code>. make sure the ip address is in the same subnet of your local network.</p>
<p>Here is an sample setting file:</p>
<pre>
config interface 'loopback'
    option ifname 'lo'
    option proto 'static'
    option ipaddr '127.0.0.1'
    option netmask '255.0.0.0'

config globals 'globals'
    option ula_prefix 'fd50:aa02:b3ad::/48'

config interface 'lan'
    option type 'bridge'
    option ifname 'eth0'
    option proto 'static'
    option ipaddr '192.168.0.10'
    option netmask '255.255.255.0'
    option ip6assign '60'
    option gateway '192.168.0.1'
    option dns '192.168.0.1'
</pre>
<p>then restart the network service:</p>
<code>/etc/init.d/network restart</code>
<p>to check the local network setting is functioning, try to ssh the system from another machine:</p>
<code>ssh root@192.168.0.10</code>
<p>to check the gateway and dns to public network setting is functioning, try to ping a public network address:</p>
<code>ping google.com</code>


<h3>Setup Bluetooth</h3>
<p>Check status of devices:</p>
<code>hciconfig</code>
<code>sudo service bluetooth status</code>
<p>Check block status of device:</p>
<code>rfkill</code>
<p>bluetooth needs to be unblocked:</p>
<code>rfkill unblock bluetooth</code>
<p>Bluez library is needed for bluetooth mouse/ keyboard to work:</p>
<code>sudo apt install bluetooth pi-bluetooth bluez blueman</code>
<p>Use the blueman icon on desktop</p>

<h3>Setup Wifi</h3>
<p>Check status of devices:</p>
<code>ip a</code>
<p>or</p>
<code>cat /proc/net/dev</code>
<p>Check wifi status:</p>
<code>wifi status</code>
<p>Edit wifi config:</p>
<code>vim /etc/config/wireless</code>
<pre>
config wifi-device 'radio0'
    option type 'mac80211'
    option channel '7'
    option hwmode '11g'
    option path 'platform/soc/fe300000.mmcnr/mmc_host/mmc1/mmc1:0001/mmc1:0001:1'
    option country 'IE'

config wifi-iface 'default_radio0'
    option device 'radio0'
    option network 'lan'
    option mode 'ap'
    option ssid 'TP-LINK_WRT2'
    option encryption 'psk2'
    option key 'secret'
</pre>
<p>Remember to change the string <code>'secret'</code> to a stronger password</p>
<p>Reload network:</p>
<code>service network reload</code>
<p>To check if an Access Point is created and put on air:</p>
<code>iw dev</code>
<p>To check debug messages:</p>
<code>dmesg</code>
<p>To check the debug log:</p>
<code>logread</code>

<h3>Setup nftables</h3>
<p>according to <a href="https://openwrt.org/docs/guide-user/firewall/misc/nftables">documentation of openWRT</a>, we disable the loading of iptable NAT functionalities:</p>
<code>rm /etc/modules.d/ipt-nat</code>
<p>this file holds the following content:</p>
<pre>
iptable_nat
xt_MASQUERADE
xt_REDIRECT
xt_nat
</pre>
<p>install nftables</p>
<code>opkg update</code><br/>
<code>opkg install nftables</code>
<p>load kernel module required for Netwokr Address Translation:</p>
<code>opkg install kmod-nft-nat</code>

<h3>Notes on Packages</h3>
<p>The opkg package repository for Raspberry Pi 4B is a development branch, which updates frequently and not yet has a stable release. In case of a dependency mismatch, either build everything from source or you need to reflash the microSD with the latest snapshot.</p>


<h2>GitLab Continuous Integration</h2>
<p>This will setup a Build Server to run the tests. A daemon called "runner" listens to the GitLab server and calls executors when notified of changes.</p>
<p>Download gitlab-runner:</p>
<code>wget https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-runner_amd64.deb</code>
<br/>
<p>Setup gitlab-runner</p>
<code>sudo dpkg -i gitlab-runner_amd64.deb</code>
<p>A Specific Runner will be set up to execute the pipeline. The runner will run locally in the Build Server and receives notifications from GitLab/SCM server. For that an authentication token need to be first obtained from GitLab. Go to the GitLab project page, you will find the token under "Settings", "CI/CD", "Runners", "Specific Runners", "Set up a specific Runner manually", "registration token".</p>
<p>Register an Executor:</p>
<pre><code>
sudo gitlab-runner register \
  --non-interactive \
  --url "https://gitlab.fraunhofer.de" \
  --registration-token "PROJECT_REGISTRATION_TOKEN" \
  --executor "shell" \
  --description "robovaas-executor" \
  --run-untagged="true" \
  --locked="false" \
  --access-level="not_protected"
</code></pre>
<p>Grant gitlab-runner root access right:</p>
<code>sudo usermod -a -G sudo gitlab-runner</code>
<p>then follow previous instructions to allow gitlab-runner to sudo without password prompt</p>


<h2>Network Tests</h2>
<h3>Send and Receive UDP</h3>
<p>To listen to a udp port:</p>
<code>sudo tcpdump -i eno1 port 9000 -X</code>
<p>replace <code>eno1</code> with your target network interface.</p>
<p>To send some text messages to a port:</p>
<code>echo "testing" > /dev/udp/192.168.0.102/9000</code>


<h2>Networking</h2>
<h3>Hostname Discovery</h3>
<p>Discover other Hostnames on the same network</p>
<code>nmap -sn 192.168.0.*</code>
<p>Install Network Discovery Tools</p>
<code>sudo apt install net-tools</code>
<p>Do a fast Address Resolution Protocol scan</p>
<code>sudo arp-scan --localnet --interface=eno1</code>
<p>Show the Hostnames of all network devices</p>
<code>sudo arp</code>

<h2>Janus Gateway</h2>
<h3>Send and Receive UDP</h3>
<p>To listen to a udp port:</p>
<code>sudo tcpdump -i eno1 port 9000 -X</code>
<p>replace <code>eno1</code> with your target network interface.</p>
<p>To send some text messages to a port:</p>
<code>echo "testing" > /dev/udp/192.168.0.102/9000</code>

<h3>Install Janus Server</h3>
<code>sudo apt install janus</code>
<h3>Stop Janus Daemon</h3>
<code>sudo service janus stop</code>
<h3>Kill all local Janus instances</h3>
<code>sudo killall janus</code>
<h3>Enable Websocket Plugin, RestAPI Plugin, Video Room Plugin</h3>
<code>sudo cp janus.transport.websockets.jcfg.sample janus.transport.websockets.jcfg</code><br>
<code>sudo cp janus.transport.http.jcfg.sample janus.transport.http.jcfg</code><br>
<code>sudo cp janus.plugin.videoroom.jcfg.sample janus.plugin.videoroom.jcfg</code><br>
<h3>Start Janus Server</h3>
<code>sudo janus</code>


<h2>Programming in C</h2>
<p>To install the source files (.h and .c files) of a library using <code>apt</code>, usually the package name is prefixed with <code>lib</code> and suffixed with <code>-dev</code>. For example, the library foo has the <code>apt</code> package name <code>libfoo-dev</code> </p>
<p>Download source file using <code>apt</code>:</p>
<code>sudo apt install libfoo-dev</code>
<p>To check if a Library is installed, inspect pkg-config for .pc entries:</p>
<code>pkg-config --list-all | grep foo</code>
<p>To check the directory where the installed header files and object files can be found:</p>
<code>PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1 PKG_CONFIG_ALLOW_SYSTEM_LIBS=1 pkg-config libfoo --cflags --libs</code>
<p>the results shows the header file can be found in <code>/usr/include/</code>. Upon inspecting <code>/usr/include/</code> we can locate the header file <code>libfoo.h</code></p>
<p>after the libraries are ensured to be available, fabricate the corresponding makefile:</p>
<details open>
<summary><code>makefile</code></summary>
<pre>
PKG_CONFIG := pkg-config
CC     := gcc
PKGS := glib-2.0 json-glib-1.0 libfoo gstreamer-1.0 gstreamer-sdp-1.0 gstreamer-webrtc-1.0
LIBS   := $(shell $(PKG_CONFIG) --libs --cflags $(PKGS))
CFLAGS := -O0 -ggdb -Wall -fno-omit-frame-pointer $(shell $(PKG_CONFIG) --cflags $(PKGS))

all: main.c
    "$(CC)" $(CFLAGS) $^ $(LIBS) -o ./build/main       
</pre>
</details>

<h3>pkg-config</h3>
<p>to check the search paths for .pc files:</p>
<code>pkg-config --variable pc_path pkg-config</code>

<h3>Working with locally compiled libraries</h3>
<p>If some libraries are compiled elsewhere, extra setup is needed to </p>


<h2>Setup Streaming on Raspbian</h2>
<h3>Force display even without HDMI connected</h3>
<p>edit the config file:</p>
<code>sudo nano /boot/config.txt</code>
<p>uncomment the lines regarding framebuffers.</p>
<p>If a blank screen is showing when accessing through VNC, set the resolution to 1280x720 in raspi-config.</p>
<h3>Enable SSH and Camera</h3>
<code>sudo raspi-config</code>
<h3>Setup H264 Profile as Main</h3>
<code>v4l2-ctl --set-ctrl h264_profile=1</code>
<h3>Install Gstreamer</h3>
<code>sudo apt install gstreamer1.0-tools gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly</code>
<h3>Enable v4l2 kernel module every time after system start:</h3>
<code>sudo modprobe bcm2835-v4l2</code>
<h3>Client: Fetch Video and Push to UDP port of Server</h3>
<code>gst-launch-1.0 v4l2src device=/dev/video0  ! videoconvert ! x264enc tune=zerolatency ! video/x-h264, profile=baseline ! rtph264pay ! udpsink host=192.168.0.80 port=5600</code>
<h3>Raspivid hardward H264 Streaming</h3>
<code>raspivid -n -w 1920 -h 1080 -b 4500000 -fps 30 -vf -hf -t 0 -o - | gst-launch-1.0 -v fdsrc !  h264parse ! queue ! rtph264pay config-interval=10 pt=96 ! udpsink host=192.168.0.80 port=5600</code>
<p>alternatively:</p>
<code>gst-launch-1.0 -v rpicamsrc camera-number=0 ! capsfilter caps=\"video/x-h264,width=1280,height=720,framerate=30/1\" ! h264parse ! queue ! rtph264pay config-interval=10 pt=96 ! capsfilter caps=\"application/x-rtp, media=video, clock-rate=90000, encoding-name=H264\" ! udpsink host=192.168.0.239 port=5600</code>
<h3>Server: View Video on Server</h3>
<code>gst-launch-1.0 -v udpsrc uri=udp://192.168.0.80:5600 caps = "application/x-rtp, media=(string)video, clock-rate=(int)90000, encoding-name=(string)H264, payload=(int)96" ! rtph264depay ! decodebin ! videoconvert ! xvimagesink sync=false</code>


<h2>Create Virtual Webcam</h2>
<p>stream from raspberry webcam as before, use 720p since Teams only accepts lower resolution:</p>
<code>gst-launch-1.0 -v rpicamsrc camera-number=0 ! capsfilter caps=\"video/x-h264,width=1280,height=720,framerate=30/1\" ! h264parse ! queue ! rtph264pay config-interval=10 pt=96 ! capsfilter caps=\"application/x-rtp, media=video, clock-rate=90000, encoding-name=H264\" ! udpsink host=192.168.0.239 port=5600</code>
<p>on the target machine where virtual cam is to be installed, install the kernel module that creates a virtual v4l2 device:</p>
<code>sudo apt install v4l2loopback-utils</code>
<p>create the virtual device:</p>
<code>sudo modprobe v4l2loopback video_nr=0</code>
<p>read the stream from raspberry and push to the virtual device:</p>
<code>gst-launch-1.0 udpsrc port=5600 caps = "application/x-rtp, media=(string)video, clock-rate=(int)90000, encoding-name=(string)H264, payload=(int)96" ! rtph264depay ! queue ! avdec_h264 ! decodebin ! videorate ! video/x-raw, framerate=30/1 ! videoconvert ! v4l2sink sync=false device=/dev/video0</code>
<p>to use more than one webcam, remove the module and reload it specifying two target devices:</p>
<code>sudo modprobe -r v4l2loopback</code>
<code>sudo modprobe v4l2loopback video_nr=0,1</code>
<p>confirm there are two devices now:</p>
<code>v4l2-ctl --list-device</code>


<h2>Install NVIDIA Driver</h2>
<p>Download both the NVIDIA driver for the GPU, and the cuda developement kit. Use the generic bash installer instead of .deb package.</p>
<p></p>


<h2>Node and NPM</h2>
<h3>Upgrade NodeJS</h3>
<p>Install n</p>
<code>sudo npm install -g n latest</code>
<br>
<code>sudo n latest</code>
<h3>Troubleshooting error during NPM install</h3>
<p>Check Available Versions of a package</p>
<code>npm view package_name</code>


<h2>Build a Qt Project</h2>
<h3>Install Dependencies</h3>
<code>sudo apt install qt5-default</code>
<h3>Install Qt Developement Libraries</h3>
<code>sudo apt-get install libqt5*dev</code>

<h2>Setup WiFi/WLAN Access Point using external wireless USB dongle</h2>
<h3>Install Driver for WiFi USB </h3>
<p>As an example we are using the dongle Edimax EW-7811UAC. The respective driver/ linux kernel module is located in:</p>
<code>git clone https://github.com/gnab/rtl8812au.git</code>
<code>cd rtl8812au</code>
<code>git checkout 033a465431aa538b9850691b330255493ec0e2f1</code>
<p>git clone the repo and then follow the instructions in the Readme. For Ubuntu operating system, there might be needed to disable the Security Boot:</p>
<code>sudo apt install modutil && sudo mokutil --disable-validation</code>
<p>then reboot and follow the on screen instruction to disable the security boot.</p>
<h3>Create Hotspot via Network Manager</h3>
<p>Open the Network Manager from the task panel. Create a new Wi-Fi connection. Specify the SSID, set the mode as Access Point. Restrict the device to the USB Dongle. Set up a WPA/WPA2 Personal Password.</p>
<h3>Setup any Raspberry Pi to autoconect to USB Dongle</h3>
<p>Edit the WiFi connection profiles similar to the example below:</p>
<code>sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</code>
<pre>
network={
    ssid="usb_dongle_access_point_0"
    psk="password_ap0"
    key_mgmt=WPA-PSK
    priority=2 # larger value means higher priority
}

network={
    ssid="home_router"
    psk="password_router0"
    key_mgmt=WPA-PSK
    priority=1 # larger value means higher priority
}</pre>


<h2>Creating an UTC ISO 8601 Timestamp</h2>
<code>datetime.datetime.now(datetime.timezone.utc).isoformat(timespec='seconds')</code>


<h2>Generating a Random String of 16 bytes of entropy</h2>
<p>note the base64 has 6 bits of entropy per character only, therefore the length of string exceeds 16</p>
<code>openssl rand --base64 16</code>


<h2>Network Routing Metric</h2>
<p>when you check the routing table using <code>ip r</code>, each interface has a different metric. The routes with lower metric will be considered to cheaper to send/receive network packets and hence gets priorty when routing packets to external ip addresses (e.g. internet). Linux by default gives ethernet lowest metric, then comes wireless. There are times that you need to change the metric. e.g. LTE dongle recognised as ethernet while they should be the most expensive.</p>
<p>edit the DHCP Client settings</p>
<code>sudo nano /etc/dhcpcd.conf</code>
<p>add the section</p>
<pre>
# overriding default metrics for interfaces
interface eth1 # not ethernet, it is in fact LTE
metric 404; # LTE dongle should have higher metric
</pre>
<code>sudo service dhcpc restart</code>


<h2>Setup Radio Receiver</h2>
<h3>ADS-B Receiver</h3>
<p>install software for dongle</p>
<code>sudo apt install rtl-sdr</code>
<p>confirm the default kernel module for dvb is running</p>
<code>lsmod | egrep 'sdr|dvb'</code>
<p>remove the default kernel module for decoding video broadcast data (dvb)</p>
<code>sudo rmmod rtl2832_sdr dvb_usb_rtl28xxu dvb_usb_v2 rtl2832 dvb_core</code>
<p>blacklist the unwanted dvb module</p>
<code>sudo nano /etc/modprobe.d/blacklist-dvb.conf</code>
<p>add the following content into the file:</p>
<pre>
    # for radio reception instead of dvb
    blacklist dvb_usb_rtl28xxu
</pre>
<p>restart, or replug the dongle, check <code>dmesg</code> to confirm the kernel is loaded correctly.</p>
<p>install the parser</p>
<code>sudo apt install rtl-sdr</code>
<p>test if the parser is working</p>
<code>rtl_adsb</code>
<h2>Create a Virtual Serial Device for ADS-B dumping</h2>
<p>check the current devices</p>
<code>ls -l /dev/</code>
<p>Create device node with custom device major and minor number 999, so it does not collide with system defaults</p>
<code>sudo mknod /dev/adsb_writer c 999 999</code>
<code>sudo mknod /dev/adsb_reader c 999 999</code>
<p>Create Pseudo Serial Ports and link them to the Virtual Devices</p>
<code>sudo socat -d -d pty,raw,echo=0,link=/dev/adsb_reader pty,raw,echo=0,link=/dev/adsb_writer</code>
<p>Pipe the ADSB outputs to the virtual Writer Device</p>
<code>rtl_adsb | sudo tee /dev/adsb_writer</code>
<p>Branch serial signal to multiple addresses</p>
<code>cat /dev/ttyAMA0 | tee >&2 >(sudo socat - udp:10.111.222.33:4444) >(sudo socat - udp:111.222.333.444:5555)</code>


<h2>Setup NFS System</h2>
<h3>Host setup (e.g. 192.168.0.234)</h3>
<p>install dependencies</p>
<code>sudo apt install nfs-kernel-server</code>
<p>a config file <code>/etc/exports</code> is created. to share a folder on a host to everybody in the local network</p>
<p>before configuring export option, check your user uid and gid by <code>id</code>.</p>
<code>sudo nano /etc/exports</code>
<p>and add the following line:</p>
<pre>
    /home/user/workspace/target_folder     192.168.0.0/24(rw,sync,no_subtree_check,all_squash,anonuid=1001,anongid=1001)
</pre>
<p>if you want all user to act on behalf of your account, change the anonuid and anongid to match the target uid/gid.</p>
<p>apply and update the settings</p>
<code>sudo exportfs -ra</code>
<h3>Client setup</h3>
<p>install dependencies</p>
<code>sudo apt install nfs-common</code>
<p>for the clients, mount the shared folder to /mnt/shared_folder_A</p>
<code>sudo mkdir /mnt/shared_folder_A</code>
<code>sudo mount -t nfs4 192.168.0.234:/home/user/workspace/target_folder /mnt/shared_folder_A</code>


<h2>Calculate Timezone</h2>
<p>Translate Local Time in Shanghai to Time in London.</p>
<code>TZ='Europe/London' date --date='TZ="Asia/Shanghai" 20220507T21:00'</code>
<p>Get ISO Timestamp</p>
<code>date --utc --iso-8601=minutes --date='TZ="Asia/Shanghai" 20220507T21:00'</code>


<h2>Setup a Debian Server</h2>
<p>for the first time setting up a new debian machine</p>
<h3>Flash OS onto a USB Memory Stick</h3>
<p>Obtain Minimal Official Image:</p>
<code>cd ~/Downloads</code>
<code>wget https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-11.3.0-amd64-netinst.iso</code>
<p>Plug in USB Memory Stick, identify the partition in <code>sudo fdisk -l</code>, in our case <code>/dev/sdc</code>. If it is also auto mounted, as shown in <code>df</code>, run e.g.:</p>
<code>sudo umount /media/kongnihcua/1f84f91b-62f9-45f7-ac48-38ce064f32c1</code>
<p>Format the card:</p>
<code>sudo mkfs.ext4 /dev/sdc</code>
<p>Flash image:</p>
<code>sudo dd if=./debian-11.3.0-amd64-netinst.iso of=/dev/sdc bs=2M conv=fsync</code>
<p>pull out the stick and plug to the new machine</p>
<p>boot the new machine and complete the initial setup</p>
<p>login as root for initial setup:</p>
<code>su root</code>
<p>obtain the ethernet driver corresponds to your ethernet card (in our case rtl8125b-2.fw) and save it to a USB drive</p>
<p>plug in the USB drive. use <code>dmesg</code> to find out the drive name (e.g. /dev/sdb) </p>
<p>mount the usb drive onto the new machine file system:</p>
<code>mkdir /mnt/sandisk && mount /dev/sdb1 /mnt/sandisk/</code>
<p>copy the driver to the target folder:</p>
<code>cp /mnt/sandisk/rtl8125b-2.fw /lib/firmware/rtl_nic/</code>
<p>update root filesystem image for booting the kernel:</p>
<code>/sbin/update-initramfs -u</code>
<p>reboot the system</p>
<code>/sbin/reboot</code>
<h3>Setup Basic Network Connectivity</h3>
<p>check the ethernet device interface name:</p>
<code>ip a</code>
<p>in our case it is enp2s0</p>
<p>edit the network interface configuration</p>
<code>nano /etc/network/interfaces</code>
<p>and add a section:</p>
<pre>
# first time setup before installing network manager
auto enp2s0
allow-hotplug enp2s0
iface enp2s0 inet dhcp
</pre>
<p>restart the network service</p>
<code>/sbin/service networking restart</code>
<p>now an ip address to be obtained from your local network router. check using <code>/sbin/service networking status</code> or <code>ip a</code></p>
<h3>Setup APT</h3>
<p>now the network is ready and we can install additional packagess. set up the sources for debian package manager <code>apt</code></p>
<code>apt edit-sources</code>
<p>check the following entries are present:</p>
<pre>
deb http://deb.debian.org/debian bullseye main
deb-src http://deb.debian.org/debian bullseye main

deb http://security.debian.org/debian-security bullseye-security main
deb-src http://security.debian.org/debian-security bullseye-security main

deb http://deb.debian.org/debian/ bullseye-updates main
deb-src http://deb.debian.org/debian/ bullseye-updates main
</pre>
<p>save the file and then update apt:</p>
<code>apt update</code>
<h3>Install sudo</h3>
<p>the sudo command is not included in the minimal debian image. up till now we have to explicitly add the prefix <code>/sbin/</code> to call the root commands</p>
<p>install sudo package:</p>
<code>apt install sudo</code>
<h3>Install ssh</h3>
<p>ssh is required to operate on a headless server.</p>
<code>sudo apt install ssh</code>
<h3>Setup Visudo</h3>
<p>see the visudo section above.</p>

<h3>Setup Harddrive</h3>
<p>check all the disks:</p>
<code>sudo fdisk -l</code>
<p>check the uuid of the device:</p>
<code>sudo blkid</code>
<p>for databases, create a new partition and format it into XFS format.</p>
<p>first install dependencies:</p>
<code>sudo apt install xfsprogs</code>
<p>we are using all the space, so partition is not needed.</p>
<p>format the partition</p>
<code>sudo mkfs.xfs /dev/sda</code>
<p>if there is error during writing zero to the new harddrive, try mkfs.ext4 first and then mkfs.xfs</p>


<h2>Setup VPN</h2>
<p>A PKI (Public Key Infrastructure) is required to establish a secure network. A basic set consists of three entities, namely the Certificate Authority which establishes root trust, the VPN Host Server that manages all login and sessions, and the Clients.</p>
<p>install dependencies on all participating machines:</p>
<code>sudo apt install openvpn</code>

<h3>Setup CA</h3>
<p>setup Certificate Authority first.</p>
<p>change directory to the openvpn folder:</p>
<code>cd /etc/openvpn</code>
<p>Initiate the PKI workspace:</p>
<code>sudo /usr/share/easy-rsa/easyrsa init-pki</code>
<p>a directory <pre>pki</pre> is created. create a public master Certificate Authority (CA) certificate and a private key:</p>
<code>sudo /usr/share/easy-rsa/easyrsa build-ca</code>
<p>use the default when prompted. Then the cert <code>/etc/openvpn/pki/ca.crt</code> is created.</p>


<h3>Setup VPN Host/ Server</h3>
<p>change directory to <code>/etc/openvpn</code></p>
<code>cd /etc/openvpn</code>
<p>generate a certificate request and a private key pair</p>
<code>sudo /usr/share/easy-rsa/easyrsa gen-req 12.345.678.90 nopass</code>
<p>setup Diffie-Hellman parameters, which will be used for session key generation. A minimum of 1024 bits is required.</p>
<code>sudo /usr/share/easy-rsa/easyrsa gen-dh</code>
<p>the generated file is <code>/etc/openvpn/pki/dh.pem</code></p>
<p>Using the Private Key of Certificate Authority, sign the host's public key:</p>
<code>sudo /usr/share/easy-rsa/easyrsa sign-req server 12.345.678.90</code>
<p>the issued certificate is found at <code>/etc/openvpn/pki/issued/12.345.678.90.crt</code></p>

<p>(optional) now issue a private-public key pair for the first client machine</p>
<code>sudo /usr/share/easy-rsa/easyrsa gen-req myclient1 nopass</code>
<p>(optional) Using the Private Key of Certificate Authority, sign the client's public key:</p>
<code>sudo /usr/share/easy-rsa/easyrsa sign-req client myclient1</code>

<h3>Setup Client</h3>
<p>you can also create a certificate request and a private key on the client machine first.</p>
<p><code>sudo apt install openvpn</code></p>
<p>change directory to <code>/etc/openvpn</code></p>
<p>optional: if there is already pki initiated, skip this step:</p>
<p><code>sudo /usr/share/easy-rsa/easyrsa init-pki</code></p>
<p><code>sudo /usr/share/easy-rsa/easyrsa gen-req client_hostname nopass</code></p>
<p>the generated items are saved to <pre>/etc/openvpn/pki/reqs/client_hostname.req</pre> and <pre>/etc/openvpn/pki/private/client_hostname.key</pre>.</p>
<p>copy manually the content of the request:</p>
<code>sudo nano /etc/openvpn/pki/reqs/client_hostname.req</code>
<p>send the request to the CA Server and save it to <pre>/etc/openvpn/pki/incoming/client_hostname.req</pre>:</p>
<code>sudo mkdir /etc/openvpn/pki/incoming sudo nano /etc/openvpn/pki/incoming/client_hostname.req</code>
<p>at the server, import the incoming request</p>
<code>sudo /usr/share/easy-rsa/easyrsa import-req /etc/openvpn/pki/incoming/client_hostname.req client_hostname</code>
<p>sign the request using CA</p>
<code>cd /etc/openvpn && sudo /usr/share/easy-rsa/easyrsa sign-req client client_hostname</code>
<p>now a certificate is issued to <pre>/etc/openvpn/pki/issued/client_hostname.crt</pre>.</p>
<p>print the certificate: <code>sudo cat /etc/openvpn/pki/issued/client_hostname.crt</code></p>
<p>at the client, import the signed certificate:</p>
<code>sudo mkdir /etc/openvpn/pki/issued && sudo nano /etc/openvpn/pki/issued/client_hostname.crt</code>
<p>on client, import CA public certificate from server:</p>
<code>sudo nano /etc/openvpn/pki/ca.crt</code>

<h3>Setup TLS HMAC Signature Authentication Mechanism</h3>
<p>UDP Handshake Packets can be signed with a shared secret for integrity check.</p>
<p>copy the <code>/etc/openvpn/ta.key</code> from server to client.</p>


<h3>Setup Client on Server side</h3>
<p>move to the directory where init-pki was called:</p>
<p><code>cd /etc/openvpn </code></p>
<p>create a new pair of Client Private Key and Client Certificate on the VPN server:</p>
<p><code>sudo /usr/share/easy-rsa/easyrsa gen-req client_hostname nopass</code></p>
<p><code>sudo /usr/share/easy-rsa/easyrsa sign-req client client_hostname</code></p>
<p>copy the two files to the client machine:</p>
<p><code>sudo cat /etc/openvpn/pki/issued/client_hostname.crt</code></p>
<p><code>sudo cat /etc/openvpn/pki/private/client_hostname.key</code></p>
<p><code>sudo cat /etc/openvpn/pki/ca.crt</code></p>
<p><code>sudo cat /etc/openvpn/ta.key</code></p>
<p>prepare the config file. name if <code>client.conf</code> if in linux, or <code>client.ovpn</code> in android.</p>
<details>
<summary>
</summary>
<pre>
##############################################
# Sample client-side OpenVPN 2.0 config file #
# for connecting to multi-client server.     #
#                                            #
# This configuration can be used by multiple #
# clients, however each client should have   #
# its own cert and key files.                #
#                                            #
# On Windows, you might want to rename this  #
# file so it has a .ovpn extension           #
##############################################

# Specify that we are a client and that we
# will be pulling certain config file directives
# from the server.
client

# Use the same setting as you are using on
# the server.
# On most systems, the VPN will not function
# unless you partially or fully disable
# the firewall for the TUN/TAP interface.
;dev tap
dev tun

# Windows needs the TAP-Win32 adapter name
# from the Network Connections panel
# if you have more than one.  On XP SP2,
# you may need to disable the firewall
# for the TAP adapter.
;dev-node MyTap

# Are we connecting to a TCP or
# UDP server?  Use the same setting as
# on the server.
#;proto tcp
proto udp

# The hostname/IP and port of the server.
# You can have multiple remote entries
# to load balance between the servers.
remote vpn_server_hostname 12345
#;remote my-server-2 1194

# Choose a random host from the remote
# list for load-balancing.  Otherwise
# try hosts in the order specified.
;remote-random

# Keep trying indefinitely to resolve the
# host name of the OpenVPN server.  Very useful
# on machines which are not permanently connected
# to the internet such as laptops.
resolv-retry infinite

# Most clients don't need to bind to
# a specific local port number.
nobind

# Downgrade privileges after initialization (non-Windows only)
;user nobody
;group nogroup

# Try to preserve some state across restarts.
persist-key
persist-tun

# If you are connecting through an
# HTTP proxy to reach the actual OpenVPN
# server, put the proxy server/IP and
# port number here.  See the man page
# if your proxy server requires
# authentication.
;http-proxy-retry # retry on connection failures
;http-proxy [proxy server] [proxy port #]

# Wireless networks often produce a lot
# of duplicate packets.  Set this flag
# to silence duplicate packet warnings.
;mute-replay-warnings

# SSL/TLS parms.
# See the server config file for more
# description.  It's best to use
# a separate .crt/.key file pair
# for each client.  A single ca
# file can be used for all clients.
ca /etc/openvpn/pki/ca.crt
cert /etc/openvpn/pki/issued/client_hostname.crt
key /etc/openvpn/pki/private/client_hostname.key

# Verify server certificate by checking that the
# certificate has the correct key usage set.
# This is an important precaution to protect against
# a potential attack discussed here:
#  http://openvpn.net/howto.html#mitm
#
# To use this feature, you will need to generate
# your server certificates with the keyUsage set to
#   digitalSignature, keyEncipherment
# and the extendedKeyUsage to
#   serverAuth
# EasyRSA can do this for you.
remote-cert-tls server

# If a tls-auth key is used on the server
# then every client must also have the key.
tls-auth /etc/openvpn/ta.key 1

# Select a cryptographic cipher.
# If the cipher option is used on the server
# then you must also specify it here.
# Note that v2.4 client/server will automatically
# negotiate AES-256-GCM in TLS mode.
# See also the data-ciphers option in the manpage
cipher AES-256-CBC

# Enable compression on the VPN link.
# Don't enable this unless it is also
# enabled in the server config file.
#comp-lzo

# Set log file verbosity.
verb 4

# Silence repeating messages
;mute 20
</pre>
</details>
<p>initialize the client machine if needed:</p>
<code>sudo /usr/share/easy-rsa/easyrsa init-pki</code>
<p>again, make sure all the files are copied:</p>
<ol>
<li>/etc/openvpn/pki/issued/client_hostname.crt</li>
<li>/etc/openvpn/pki/private/client_hostname.key</li>
<li>/etc/openvpn/pki/ca.crt</li>
<li>/etc/openvpn/ta.key</li>
<li>/etc/openvpn/client.conf</li>
</ol>
<p>if in android client machine, copy all the files to device, install the <code>OpenVPN connect</code> app and then import the .ovpn profile file.</p>
<p>To simplify installation, a single inline client.ovpn file can be used, where ca, cert, key, tls-auth corresponds to contents of ca.crt, client_hostname.crt, client_hostname.key, and ta.key accordingly:</p>
<details>
<pre>
##############################################
# Sample client-side OpenVPN 2.0 config file #
# for connecting to multi-client server.     #
#                                            #
# This configuration can be used by multiple #
# clients, however each client should have   #
# its own cert and key files.                #
#                                            #
# On Windows, you might want to rename this  #
# file so it has a .ovpn extension           #
##############################################

# Specify that we are a client and that we
# will be pulling certain config file directives
# from the server.
client

# Use the same setting as you are using on
# the server.
# On most systems, the VPN will not function
# unless you partially or fully disable
# the firewall for the TUN/TAP interface.
;dev tap
dev tun

# Windows needs the TAP-Win32 adapter name
# from the Network Connections panel
# if you have more than one.  On XP SP2,
# you may need to disable the firewall
# for the TAP adapter.
;dev-node MyTap

# Are we connecting to a TCP or
# UDP server?  Use the same setting as
# on the server.
#;proto tcp
proto udp

# The hostname/IP and port of the server.
# You can have multiple remote entries
# to load balance between the servers.
remote 1.2.3.4 56789
#;remote my-server-2 1194

# Choose a random host from the remote
# list for load-balancing.  Otherwise
# try hosts in the order specified.
;remote-random

# Keep trying indefinitely to resolve the
# host name of the OpenVPN server.  Very useful
# on machines which are not permanently connected
# to the internet such as laptops.
resolv-retry infinite

# Most clients don't need to bind to
# a specific local port number.
nobind

# Downgrade privileges after initialization (non-Windows only)
;user nobody
;group nogroup

# The keepalive directive causes ping-like
# messages to be sent back and forth over
# the link so that each side knows when
# the other side has gone down.
# Ping every 10 seconds, assume that remote
# peer is down if no ping received during
# a 120 second time period.
keepalive 10 120

# Try to preserve some state across restarts.
persist-key
persist-tun

# If you are connecting through an
# HTTP proxy to reach the actual OpenVPN
# server, put the proxy server/IP and
# port number here.  See the man page
# if your proxy server requires
# authentication.
;http-proxy-retry # retry on connection failures
;http-proxy [proxy server] [proxy port #]

# Wireless networks often produce a lot
# of duplicate packets.  Set this flag
# to silence duplicate packet warnings.
;mute-replay-warnings

# SSL/TLS parms.
# See the server config file for more
# description.  It's best to use
# a separate .crt/.key file pair
# for each client.  A single ca
# file can be used for all clients.
;ca /etc/openvpn/pki/ca.crt
;cert /etc/openvpn/pki/issued/minidebian.crt
;key /etc/openvpn/pki/private/minidebian.key
&lt;ca&gt;
-----BEGIN CERTIFICATE-----
MIIDSzCCAjOgAwIBAgIUPtMIAN3dfG9Z/ywPgpDK62+qkdkwDQYJKoZIhvcNAQEL
....
gsQ8ilUCogIPg+8MTbw0QpjabOCw+Srs67kGWseJhQ==
-----END CERTIFICATE-----
&lt;/ca&gt;

&lt;cert&gt;
Certificate:
    ...
    Signature Algorithm: sha256WithRSAEncryption
         ...
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
&lt;/cert&gt;

&lt;key&gt;
-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----
&lt;/key&gt;

# Verify server certificate by checking that the
# certificate has the correct key usage set.
# This is an important precaution to protect against
# a potential attack discussed here:
#  http://openvpn.net/howto.html#mitm
#
# To use this feature, you will need to generate
# your server certificates with the keyUsage set to
#   digitalSignature, keyEncipherment
# and the extendedKeyUsage to
#   serverAuth
# EasyRSA can do this for you.
remote-cert-tls server

# If a tls-auth key is used on the server
# then every client must also have the key.
;tls-auth /etc/openvpn/ta.key 1
key-direction 1
&lt;tls-auth&gt;
#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
...
-----END OpenVPN Static key V1-----
&lt;/tls-auth&gt;

# Select a cryptographic cipher.
# If the cipher option is used on the server
# then you must also specify it here.
# Note that v2.4 client/server will automatically
# negotiate AES-256-GCM in TLS mode.
# See also the data-ciphers option in the manpage
cipher AES-256-CBC

# Enable compression on the VPN link.
# Don't enable this unless it is also
# enabled in the server config file.
#comp-lzo

# Set log file verbosity.
verb 4

# Silence repeating messages
;mute 20

</pre>
</details>

<h2>Setup OTG(On-The-Go)/Gadget Mode Usb WebCam</h2>
<p>In the gadget mode we set up ethernet interface via USB on a Raspberry Pi Zero. So the Pi Zero can stream video from WebCam through USB via GStreamer library.</p>
<p>Edit the SD card of the Raspberry Pi</p>
<code>/boot/config.txt</code>
<pre>
    dtoverlay=dwc2
</pre>
<code>sudo nano /etc/modules</code>
<pre>
    dwc2
    g_ether
</pre>
<p>Make sure the USB used also has the data wires available. If not the host machine cannot recognise the usb0 interface.</p>


<h2>Force UDP Packets to use specific Network Interface</h2>
<p>Suppose there are two network interfaces, one is unmetered, while the other one, wlo123456, is more secure but metered. The default route uses the unmetered network but we want to use the secure network for vpn connection (vpn server at 88.88.88.88). The vpn connection uses specific UDP outgoing port 12345.</p>
<pre>
echo 'get the IP address of the metered device...'
WIFI_DONGLE_IP=$(ip r list default dev wlo123456 | grep -o 'via [0-9]*\.[0-9]*\.[0-9]*.[0-9]*' | grep -o '[0-9].*')
echo 'add device specific route table...'
sudo ip route flush table 1
sudo ip route add 88.88.88.88/32 via $WIFI_DONGLE_IP dev wlo123456 table 1
echo 'mark all udp packets targeting 12345 destination port...'
sudo iptables -A OUTPUT -t mangle -p udp -m udp  --dport 12345 -j MARK --set-mark 1
sudo iptables -t nat -A POSTROUTING -o wlo123456 -j MASQUERADE
sudo ip rule add from all fwmark 1 table 1
sudo ip rule show
echo 'iptable summary:'
sudo iptables -t mangle -L -nv
sudo ip route show table 1
sudo service openvpn@client123 restart
</pre>


<h2>Link local folder to USB or External Drive</h2>
<p>if your local eMMC is limited in space, link your local workspace symbolically to an external drive.</p>
<code>sudo mkdir /mnt/usb_drive</code>
<code>sudo mount /dev/sda /mnt/usb_drive</code>
<code>sudo chown your_username /mnt/usb_drive</code>
<code>mkdir /mnt/usb_drive/workspace</code>
<code>ln --symbolic /mnt/usb_drive/workspace workspace</code>


<h2>Setup Nvidia Jetson Nano</h2>

<h3>Hardware Recovery Mode</h3>
<p>On the board, short the pin <code>FC REC</code> with <code>GND</code>. Power cycle and connect the USB port to a Host PC. Host PC should detect a usb Nvidia device when calling</p>
<code>lsusb</code>

<h3>Flash Base Image to eMMC</h3>
<p>prepare the Jetson Linux image. It includes Linux Kernel, UEFI bootloader, NVIDIA drivers, flashing utilities, sample filesystem based on Ubuntu, and more for the Jetson platform. <a href="https://developer.nvidia.com/embedded/jetson-linux">Info</a></p>
<p>flash the firmware  Jetson Linux Driver Package to the jetson board.</p>
<p>get the Nvidia L4T board support package</p>
<code>cd ~/Downloads && wget https://developer.nvidia.com/embedded/l4t/r32_release_v7.2/t210/jetson-210_linux_r32.7.2_aarch64.tbz2</code>
<p>get the sample rootfs (root file system)</p>
<p><code>wget https://developer.nvidia.com/embedded/l4t/r32_release_v7.2/t210/tegra_linux_sample-root-filesystem_r32.7.2_aarch64.tbz2</code></p>
<p><code>tar xf Jetson-210_Linux_R32.7.2_aarch64.tbz2</code></p>
<p><code>cd Linux_for_Tegra/</code></p>
<p><code>cd rootfs/</code></p>
<p><code>sudo tar -xf ~/Downloads/Tegra_Linux_Sample-Root-Filesystem_R32.7.2_aarch64.tbz2</code></p>
<p><code>cd ~/Downloads/Linux_for_Tegra</code></p>
<p><code>sudo ./apply_binaries.sh</code></p>
<p><code>sudo ./flash.sh jetson-nano-devkit-emmc mmcblk0p1</code></p>
<p>the board is now flashed. Unplug the USB cable, unplug the <code>FC REC</code> pin.</p>
<p>With power still on, Reset the board by shorting <code>SYS RST</code> pin with <code>GND</code> pin. Next, plug in an HDMI monitor. After a few seconds, remove the pin short. The board will power up again. </p>
<p>Now all pins should be freed. Continue the initial setup on-screen.</p>
<p>Connect the jumper wire to two <code>GND</code> pins to avoid losing the cable.</p>
<p>make sure to set the power mode to 5W, or there will be untrivial issues</p>
<p>after the initial setup/ configuration is done, log in to the new system.</p>
<p>disable unattended-upgrades: edit the file <code>/etc/apt/apt.conf.d/10periodic</code> and set <code>APT::Periodic::Update-Package-Lists</code> to <code>"0"</code></p>
<code>sudo apt remove --purge update-notifier update-notifier-common</code>

<h3>Move <code>/usr/local</code> directory to external drive</h3>
<p>due to the limited storage space, we move the <code>/usr/local</code> to an external USB drive.</p>
<p>on the host machine, plug in a usb stick (SanDisk UltraFit 57.3 GB in this case), confirm using <code>sudo fdisk -l</code> and format it into ext4. For simplicity we format it without partitioning:</p>
<code>sudo mkfs.ext4 /dev/sdd</code>
<p>Find the mount point using <code>df</code>, unmount, and re-mount the usb to <code>/mnt/jetson_usb</code>:</p>
<p><code>sudo umount -l /media/your_username/12345678-1234-1234-1234-123412341234</code></p>
<p><code>sudo mkdir /mnt/jetson_usb && sudo mount /dev/sdd /mnt/jetson_usb</code></p>
<p>copy the contents of <code>/usr</code> of the sample filesystem to the target location:</p>
<p><code>sudo cp --archive -r ~/Downloads/Linux_for_Tegra/rootfs/usr/local/* /mnt/jetson_usb</code></p>
<p>Unmount the USB by <code>sudo umount -l /mnt/jetson_usb</code></p>
<p>unplug the USB drive and plug it to the Jetson Board's USB2.0 port</p>
<p>login to the Jetson and obtain the UUID of the USB:</p>
<code>sudo lsblk -f</code>
<p>or:</p>
<code>ls /dev/disk/by-uuid/</code>
<p>open <code>fstab</code> to edit the mount points during boot:</p>
<code>sudo apt install nano && sudo nano /etc/fstab</code>
<p>add the following line:</p>
<pre>
UUID=11111111-2222-3333-4444-555555555555 /usr/local  ext4 defaults,nofail   0       2
</pre>
<p>save the file and reboot the system</p>
<p>if the boot is normal, the new <code>/usr/local</code> is functional. run <code>df</code> to confirm.</p>
<p>mark the /usr/local so we don't mix it up with the original /usr/local</p>
<code>sudo touch /usr/local/is_usb.txt</code>

<h3>create linked workspace directory on USB drive</h3>
<p>now the new <code>/usr/local</code> is mounted, create a workspace folder:</p>
<code>cd /usr/local && sudo mkdir workspace && sudo chown pi /usr/local/workspace</code>
<p>create link in home folder:</p>
<code>ln --symbolic /usr/local/workspace ~/workspace</code>

<h3>APT update issue</h3>
<p>in case the APT cannot properly update its repository list, remove the cached files before reruning <code>sudo apt update</code>:</p>
<code>sudo rm -rf /var/lib/apt/lists/*</code>
<p>in case the USB is damaged and you swapped to a new clean USB, the APT need to be forced overwriting to recover from the broken state. An example of possible hot fix is to pass dpkg a force-overwrite signal.</p>
<code>sudo apt install --fix-broken -o DPkg::options::="--force-overwrite"</code>

<h3>Install Tegra Driver and CUDA SDK</h3>
<p>use APT to install the dependencies</p>
<code>sudo apt install cuda-toolkit-10-2</code>

<h3>Install ROS Kinetic</h3>
<p>see repo of ros_desktop_full</p>


<h3>Patching</h3>
<p>direct patch by SED Stream-Editor:</p>
<code>sed --in-place 's/original/updated/g' filepath</code>
<p>Create patch by git diff</p>
<code>git -C ../nginx-rtmp-module diff > nginx-rtmp-module.patch</code>
<p>Apply patch to another git folder</p>
<code>git -C ../nginx-rtmp-module apply --whitespace=warn -p1 $PWD/nginx-rtmp-module.patch</code>


<h3>Renaming Files</h3>
<p>to remove the .part suffices for all files:</p>
<code>for i in *.part; do mv "$i" "${i/\.part/}"; done</code>


<h3>Setting up VNC</h3>

<h4>Server</h4>
<p>setup x11vnc:</p>
<code>sudo apt install x11vnc</code>
<p>start the server:</p>
<code>x11vnc -display :0 -shared -passwd sample_secret_password -forever</code>
<p>this allows a persistent opened port for unattended access. after testing this can be put to local cron jobs throught the @reboot directive:</p>
<code>crontab -e</code>
<p>
    <code>@reboot while true; do x11vnc -display :0 -shared -passwd sample_password -forever >/home/sample_user/cron_vnc.log 2>/home/sample_user/cron_vnc.err; sleep 10; done</code>
</p>
<p>for extra security, it is recommended to use TLS encryption. An example block for nginx reverse proxy server:</p>
<pre>
    # TCP streams for VNC messages

    upstream stream_vnc {
        server 192.168.0.185:5900;
    }
    
    # TLS VNC server port forwarding
    server {
        # https server
        listen 5900 ssl;
        
        ssl_certificate           ssl/tmp/example.com.cer;
        ssl_certificate_key       ssl/tmp/example.com.key;
        
        ssl_protocols         SSLv3 TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers           HIGH:!aNULL:!MD5;
        #ssl_session_cache     shared:SSL:20m;
        ssl_session_timeout   4h;
        ssl_handshake_timeout 30s;

        
        proxy_ssl off;
        # although the domain name are different, all vnc points to the same server.
        proxy_pass stream_vnc;
        proxy_timeout 30s;
        proxy_connect_timeout 30s;
    }
</pre>
<p>where the upstream points to the vnc server/machine.</p>

<h4>Client</h4>
<p>setup ssvnc</p>
<code>sudo apt install ssvnc</code>
<p>start ssvnc:</p>
<code>ssvnc</code>
<p>enter the following settings:</p>
<pre>
    VNC Host:Display = example.com:1234
    VNC Password = sample_secret_password
    Verify All Certs = false
    Use SSL = true
</pre>
<p>and then connect.</p>


<h3>Setting Up Python3</h3>
<h4>Setting Virtual Environment</h4>
<p>A Virtual Environment allows non-apt python3 packages to be installed locally for experiemental/non-stable uses.</p>
<p>activate the virtual environment:</p>
<code>python3 -m venv ~/.local</code>
<p>install a python3 package:</p>
<code>python3 -m venv ~/.local</code>
<code>~/.local/bin/pip3 install python3_package_name</code>


<h3>Network Setup</h3>
<h4>Checking Connection Priority</h4>
<code>nmcli -f autoconnect-priority,name c</code>
<h4>Changing Route Metric via <code>nmcli</code> </h4>
<code>sudo nmcli connection modify Ethernet_Client_Name ipv4.route-metric 999</code>
<h4>Reload WIFI driver</h4>
<p>Sometimes the WIFI hardware glitches out and does not work anymore. An alternative to rebooting the device is by reloading the kernel driver.</p>
<ol>
    <li>Suppose the Network Device is called <code>wlo1</code>.</li>
    <li>Check the kernel driver using: <code>ls -l /sys/class/net/wlo1/device/driver</code>. For example it shows <code>/sys/class/net/wlo1/device/driver -> ../../../../bus/pci/drivers/mt7921e</code></li>
    <li>run <code>sudo modprobe -r mt7921e</code> to unload the module</li>
    <li>run <code>sudo modprobe mt7921e</code> to reload the module</li>
</ol>
<h4>Live Network Manager Debugging</h4>
<code>sudo journalctl -fu NetworkManager</code>


<h3>Docker</h3>
<h4>Dumping an image</h4>
<code>sudo docker image save target_image:dev | gzip > ./tmp/image.tar.gz</code>
<h4>Importing an image</h4>
<code>sudo docker image load -i ./tmp/image.tar.gz</code>
<h4>Run an image in foreground</h4>
<code>sudo docker run --interactive --tty --user ubuntu -p 2222:22 -p 8080:8880 target_image:dev</code>
<h4>Commit an image</h4>
<code>sudo docker commit $image_id $image_name_alias </code>

<h3>Backup Folder using Rsync</h3>
<code>rsync --progress --no-inc-recursive --archive /mnt/hdd_01/project_data /mnt/hdd_02/project_data</code>


<h3>IP forwarding in Docker</h3>
<p>Docker alters the IP table configuration. To re-enable IPv4 packet forwarding:</p>
<code>sudo iptables -P FORWARD ACCEPT</code>

</div>
</body>
</html>
